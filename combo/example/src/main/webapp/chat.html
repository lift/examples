<!DOCTYPE html>
<html>

<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
  <title>Template</title>
</head>

<body data-lift-content-id="main">
  <div id="main" data-lift="surround?with=default;at=content">
    <h2><span data-lift="Menu.title">%*%</span></h2>

    <span data-lift="FoBo.Bs4Comp.breadCrumb?prefix=Home"></span>

    <div id="wrappedNoticeAtHead">
      <div data-lift="Msgs"></div>
    </div>

    <div class="widget">
      <center>
        <b>Group Chat <i class="far fa-comment"></i></b>
      </center>
      <br>
      <div data-lift="comet?type=Chat;name=Other;ul_id=main_ul_id;li_id=main_li_id">
        Hello
        <span name="chat_name">Your name</span>
        <ul id="main_ul_id">
          <li id="main_li_id">
            <span name="when">12:15</span>
            <span name="who">dpp</span>
            <i>
              <span name="body">My Message</span>
            </i>
          </li>
        </ul>
      </div>
    </div>
    <p>
      The total chat app, including the ask/answer component for soliciting a name comments, etc. is listed on this page. There
      is no special code to support AJAX/Comet (all the wrapping is done automatically by
      <i>Lift</i>).
    </p>

    <p>
      When the Chat comet widget is added to the page, it needs to solict the user for a "chat name". It asks the "AskName" comet
      widget for the name. Until the AskName comet widget provides a name, all rendering messages are forwarded to AskName.
      Here's the code for the "AskName":</p>

    <span class="badge badge-secondary">The
      <i>Lift</i> Scala code</span>
    <pre><code class="scala">class Chat extends CometActor with CometListener {
  private var userName = ""
  private var chats: List[ChatLine] = Nil

  /* need these vals to be set eagerly, within the scope
   * of Comet component constructor
   */
  private val ulId = S.attr("ul_id") openOr "some_ul_id"

  private val liId = S.attr("li_id")

  private lazy val li = liId.
  flatMap{ Helpers.findId(defaultHtml, _) } openOr NodeSeq.Empty

  private val inputId = Helpers.nextFuncName

  // handle an update to the chat lists
  // by diffing the lists and then sending a partial update
  // to the browser
  override def lowPriority = {
    case ChatServerUpdate(value) => {
      val update = (value filterNot (chats contains)).reverse.
      map(b => AppendHtml(ulId, line(b)))

      partialUpdate(update)
      chats = value
    }
  }

  // render the input area by binding the
  // appropriate dynamically generated code to the
  // view supplied by the template
  override lazy val fixedRender: Box[NodeSeq] =
    S.runTemplate("_chat_fixed" :: Nil,
                  "postit" -> Helpers.evalElemWithId {
                    (id, elem) =>
                      SHtml.onSubmit((s: String) => {
                        ChatServer ! ChatServerMsg(userName, s.trim)
                        SetValById(id, "")
                      })(elem)
                  } _)

  // display a line
  private def line(c: ChatLine) = {
    ("name=when" #> hourFormat(c.when) &
     "name=who" #> c.user &
     "name=body" #> c.msg)(li)
  }

  // display a list of chats
  private def displayList: NodeSeq = chats.reverse.flatMap(line)

  // render the whole list of chats
  override def render = {
    "name=chat_name" #> userName &
    ("#"+ulId+" *") #> displayList
  }

  // setup the component
  override def localSetup {
    askForName
    super.localSetup
  }

  // register as a listener
  def registerWith = ChatServer

  // ask for the user's name
  private def askForName {
    if (userName.length == 0) {
      ask(new AskName, "what's your username") {
        case s: String if (s.trim.length > 2) =>
          userName = s.trim
          reRender(true)

        case _ =>
          askForName
          reRender(false)
      }
    }
  }

}</code></pre>

    <p>
      This example demonstrates the power of Scala's Actors and
      <i>Lift</i>. With very few lines of code, we've got a complete AJAX/Comet app that has Seaside style Ask/Answer for building
      modal dialogs.
    </p>
  </div>

</body>

</html>