<!DOCTYPE html>
<html>

<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
  <title>Template</title>
</head>

<body data-lift-content-id="main">
  <div id="main" data-lift="surround?with=default2;at=content">
    <h2>Async REST</h2>
    <nav aria-label="breadcrumb" role="navigation">
      <ol class="breadcrumb">
        <li class="breadcrumb-item">
          <a href="index.html">Home</a>
        </li>
        <li class="breadcrumb-item">
          <a href="misc.html">Misc code</a>
        </li>
        <li class="breadcrumb-item active" aria-current="page">Async REST</li>
      </ol>
    </nav>

    <div>
      This example demonstrates how to use the container's Asynchronous (continuation) response capabilities such that no I/O threads
      are consumed during the calculation of the REST response value.
      <a href="/async/yep_it_works">Click</a> to see the response after a 2 second delay.
    </div>

    <span class="badge badge-secondary">The
      <i>Lift</i> Scala code</span>
    <pre><code class="scala">/**
 * An example of Lift's RestHelper and RestContinuation
 */
object AsyncRest extends RestHelper {

  // serve the URL /async/:id
  serve {
    case "async" :: id :: _ Get _ =>

      // move the calculation to another thread
      RestContinuation.async(
        reply => {
          Thread.sleep(2000) // sleep for 2 seconds
          val name1 = Thread.currentThread.getName
          val outerSesStr = S.session.toString // this should be Empty

          // the code block for reply will be executed in the
          // scope of the original request and that may mean
          // that JDBC connections are consumed, etc.
          reply{
            val name2 = Thread.currentThread.getName
            val innerSesStr = S.session.toString // this should be Full()
            &lt;i id={id}&gt;name1: {name1} outer: {outerSesStr} name2: {name2}
            inner: {innerSesStr}&lt;/i&gt;
          }
        })
  }
}</code></pre>


  </div>

</body>

</html>